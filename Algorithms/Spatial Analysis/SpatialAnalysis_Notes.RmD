---
title: "SpatialAnalysis"
author: "Tarun Reddy Aleti"
date: "4/11/2016"
output: html_document
---
### Packages
```{r, echo = TRUE, warning = FALSE, message = FALSE, results = 'hide'}
library(sp)
library(maptools)
library(maps)
library(rgdal)
library(lattice)
library(grid)
library(RColorBrewer)
library(classInt)
library(raster)
library(gstat)
library(spdep)
library(DCluster)
library(gpclib)
library(spgrass6)
```

### Spatial Points
A two-dimensional point can be described by a pair of numbers (x, y), defined over a known region. The pair of numbers define the location on the sphere exactly. Pair of numbers measured in degrees are a geographical coordinate, showing where our point is on the globe. Geographical coordinates can extend from latitude 90◦ to −90◦ in the north–south direction, and from longitude 0◦ to 360◦ or equivalently from −180◦ to 180◦ in the east–west direction.

#### Spatial Points using R
- Reading a spatial text file into R
- Viewing Top rows in the Data Frame CRAN_df
- Extracting Lat and Long information into a new dataframe CRAN_mat
- We need following information to build a Spatial Point
- Coords (matrix): Should contain lat and long data
- bbox (matrix): Object projection
- Proj4string (CRS): If we use long lat we need not input bbox
- First we need to CRS for our Spatial Point
- The SpatialPoints class extends the Spatial class by adding a coords slot, into which a matrix of point coordinates can be inserted

```{r, echo = TRUE, warning = FALSE, message = FALSE}
CRAN_df <- read.table("http://www.asdar-book.org/datasets/CRAN051001a.txt", header = TRUE)
head(CRAN_df)
CRAN_mat <- CRAN_df[ ,c("lat", "long")]
getClass("SpatialPoints")
llCRS <- CRS("+proj=longlat +ellps=WGS84")
CRAN_sp <- SpatialPoints(CRAN_mat, proj4string = llCRS)
summary(CRAN_sp)
```

#### Spatial Point Analysis, Data Extraction and Manipulation in R
- bbox
- proj4string
- coordinates
- summary
- SpatialPointsDataFrame

```{r, echo = TRUE, warning = FALSE, message = FALSE}
turtle_df <- read.csv("seamap105_mod.csv")
summary(turtle_df)
timestamp <- as.POSIXlt(strptime(as.character(turtle_df$obs_date), "%m/%d/%Y %H:%M:%S"), "GMT")
turtle_df1 <- data.frame(turtle_df, timestamp = timestamp)
turtle_df1$lon <- ifelse(turtle_df1$lon < 0, turtle_df1$lon + 360, turtle_df1$lon)
turtle_sp <- turtle_df1[order(turtle_df1$timestamp), ]
coordinates(turtle_sp) <- c("lon", "lat")
proj4string(turtle_sp) <- CRS("+proj=longlat +ellps=WGS84")
```

### Spatial Lines
A Line object is just a spaghetti collection of 2D coordinates. A Lines object is a list of Line objects, such as all the contours at a single elevation. Islands belonging to the same county SpatialLines objects are made using lists of Lines objects. 

#### Spatial Lines using R
Lines have been represented in R in a simple form as a sequence of points, based on lowering the graphic ‘pen’ at the first point and drawing to the successive points until an NA is met. Then pen is raised and moved to the next non-NA value, where it is lowered, until the end of the set of points. While this is convenient for graphics output, it is less so for associating lines with data values, because the line is not subsetted into data objects in any other way than by NA values. 

#### Spatial Line Analysis, Data Extraction and Manipulation
The approach adopted here is to start with a Line object that is a matrix of 2D coordinates, without NA values. A list of Line objects forms the Lines slot of a Lines object. An identifying character tag is also required, and will be used for constructing SpatialLines objects using the same approach as was used above for matching ID values for spatial points.
SpatialLinesDataFrame objects are defined using SpatialLines and standard data frames, and the ID fields are here required to match the data frame row names. 
- Read the sample data from library(map)
- Data is in map format and has 4 lists names “x”, “y”, “range” and “names”.
  + x is Latitude and y is Longitude
  + range is boundary box
  + names is Names of the Region
- Set the CRS conditions
- Convert the lat long matrix into Spatial Lines based on the definition above
  + Use map2SpatitalLines function for this purpose
  + Spatial Line will have lists equivalent to the names or NA present in the x or y
- Use slot function to extract information about each line in SpatialLines class
- We can perform arithmetic analysis using other R functions on this ex: sapply
  + Number of rows in each of the Line Objects
  + Number of Lines Objects each of the Line Object contains

```{r, echo = TRUE, warning = FALSE, message = FALSE}
japan <- map("world", "japan", plot = FALSE)
names(japan)
p4s <- CRS("+proj=longlat +ellps=WGS84")
SLjapan <- map2SpatialLines(japan, proj4string = p4s)
which(is.na(japan$x))
which(is.na(japan$y))
length(which(is.na(japan$x) == length(names(SLjapan))))
slot_SLjapan <- slot(SLjapan, "lines")
sapply(slot_SLjapan, function(x) dim(slot(slot(x, "Lines")[[1]], "coords"))[1])
Lines_len <- sapply(slot(SLjapan, "lines"),function(x) length(slot(x, "Lines")))
```

### Spatial Polygons
A Polygon object is a Line object with equal first and last coordinates. A polygon object is a list of polygon objects, such as all the contours at a single elevation. Islands belonging to the same county SpatialPolygons objects are made using lists Polygons objects. 

#### Spatial Polygons using R
The basic representation of a polygon is a closed line, a sequence of point coordinates where the first point is the same as the last point. A set of polygons is made of closed lines separated by NA points. Like lines, it is not easy to work with polygons represented this way. To have a data set to use for polygons, we first identify the lines. Many are islands, and so have identical first and last coordinates.

#### Spatial Polygon Analysis, Data Extraction and Manipulation
The Polygon class extends the Line class by adding slots needed for polygons and checking that the first and last coordinates are identical. The extra slots are a label point, taken as the centroid of the polygon, the area of the polygon in the metric of the coordinates, whether the polygon is declared as a hole or not – the default value is a logical NA, and the ring direction of the polygon.
- Initialize the CRS conditions
- Read the dataset using MapGen2L
- Extract Lines data using slot function
- Checking for line objects which have same initial and end coordinates
- Choosing only those lines in data set that are close polygons we can can SpatialPolygons objects

```{r, echo = TRUE, warning = FALSE, message = FALSE}
llCRS <- CRS("+proj=longlat +ellps=WGS84")
auck_shore <- MapGen2SL("auckland_mapgen.dat", llCRS)
lns <- slot(auck_shore, "lines")
islands_auck <- sapply(lns, function(x) {
  crds <- slot(slot(x, "Lines")[[1]], "coords")
  identical(crds[1, ], crds[nrow(crds), ])
})
table(islands_auck)

islands_sl <- auck_shore[islands_auck]
list_of_Lines <- slot(islands_sl, "lines")
list_of_Polygons <- lapply(list_of_Lines, function(x) {
  Polygons(list(Polygon(slot(slot(x, "Lines")[[1]], "coords"))), ID = slot(x, "ID"))
})
islands_sp <- SpatialPolygons(list_of_Polygons, proj4string = CRS("+proj=longlat +ellps=WGS84"))
summary(islands_sp)
slot(islands_sp, "plotOrder")
order(sapply(slot(islands_sp, "polygons"), function(x) slot(x, "area")), decreasing = TRUE)
```

#### Spatial Polygon Data Frame Objects
As with other spatial data objects, SpatialPolygonsDataFrame objects bring together the spatial representations of the polygons with data. The identifying tags of the Polygons in the polygon slot of a SpatialPolygons object are matched with the row names of the data frame to make sure that the correct data rows are associated with the correct spatial objects.
- Read the data set from library(map)
- Extracting IDs for the state
- Create Spatial Polygons using the IDs
- Match the Spatial Polygons IDs to other external data set ID
- We can combine Spatial Polygon with other data set only if they have same ID’s
- IDs to match they need to have exact same string
- We need not create Spatial Polygons every time to manipulate the data

```{r, echo = TRUE, warning = FALSE, message = FALSE}
state.map <- map("state", plot = FALSE, fill = TRUE)
IDs <- sapply(strsplit(state.map$names, ":"), function(x) x[1])
state.sp <- map2SpatialPolygons(state.map, IDs = IDs, 
                                proj4string = CRS("+proj=longlat +ellps=WGS84"))
sat <- read.table("http://www.asdar-book.org/datasets/state.sat.data_mod.txt", row.names = 5, header = TRUE)
state_polygon_ids <- sapply(slot(state.sp, "polygons"), function(x) slot(x, "ID"))
id <- match(row.names(sat), state_polygon_ids)
row.names(sat)[is.na(id)]
state.spdf <- SpatialPolygonsDataFrame(state.sp, sat[!is.na(id), ])

DC <- "district of columbia"
not_dc <- !(row.names(slot(state.spdf, "data")) == DC)
state.spdf1 <- state.spdf[not_dc, ]
length(slot(state.spdf1, "polygons"))
```

#### Topographical Representation of Polygons in GIS
- Underlying structure of the data stored in maps
- Boundaries between polygons are stored only once as arcs between nodes
- Polygons are constructed on the fly from lists of directed boundary arcs, including boundaries with the external space – void – not included in any polygon

#### Holes and Ring Direction
- The Polygon objects are always drawn based upon user input. In order to differentiate a hole from a lake following approach has been adopted in sp package: 
    + Two markers commonly encountered in practice, marking polygons as holes with a logical (TRUE/FALSE) flag, the hole slot, and using ring direction – clockwise rings are taken as not being holes, anti-clockwise as being holes. 
    + This is needed because the non-topological representation of polygons has no easy way of knowing that a polygon represents an internal boundary of an enclosing polygon, a hole, or lake.

```{r, echo = TRUE, warning = FALSE, message = FALSE}
load("high.RData")
manitoulin_sp <- high$SP
length(slot(manitoulin_sp, "polygons"))
sapply(slot(slot(manitoulin_sp, "polygons")[[1]], "Polygons"),
       function(x) slot(x, "hole"))
sapply(slot(slot(manitoulin_sp, "polygons")[[1]], "Polygons"),
       function(x) slot(x, "ringDir"))

```

### Spatial Pixels and Grids
The point, line, and polygon objects we have considered until now have been handled one-by-one. Grids are regular objects requiring much less information to define their structure. Once the single point of origin is known, the extent. of the grid can be given by the cell resolution and the numbers of rows and columns present in the full grid. This representation is typical for remote sensing and raster GIS, and is used widely for storing data in regular rectangular cells, such as digital elevation models, satellite imagery, and interpolated data from point measurements, as well as image processing.

#### Spatial Pixels and Grids using R
There are two representations for data on regular rectangular grids (oriented N-S, E-W): SpatialPixels and SpatialGrid. SpatialPixels are like SpatialPoints objects, but the coordinates have to be regularly spaced. The coordinates are stored, as are grid indices. SpatialPixelsDataFrame objects only store attribute data where it is present, but need to store the coordinates and grid indices of those grid cells SpatialGridDataFrame objects do not need to store coordinates, because they fill the entire defined grid, but they need to store NA values where attribute values are missing.

#### Spatial Grids Analysis, Data Extraction and Manipulation
- Download the file to your current directory
- Load the Listed data set
- Extract the Spatial Polygon data from the list
- Get boundary box for the Spatial Polygon
- Create vectors for grid cell offset, cell size and cell dimensions
- Use them to create Spatial Grid Topology
- Using CRS and Topology we can create Spatial Grid

```{r, echo = TRUE, warning = FALSE, message = FALSE}
bb <- bbox(manitoulin_sp)
cs <- c(0.01, 0.01)
cc <- bb[, 1] + (cs/2)
cd <- ceiling(diff(t(bb))/cs)
manitoulin_grd <- GridTopology(cellcentre.offset = cc, cellsize = cs, cells.dim = cd)
p4s <- CRS(proj4string(manitoulin_sp))
manitoulin_SG <- SpatialGrid(manitoulin_grd, proj4string = p4s)
summary(manitoulin_SG)
```

#### Spatial Pixels Analysis, Data Extraction and Manipulation
Spatial Pixels is an alternate way of storing the data that is in Spatial Grid. It comes in handy especially when there is lot of missing data in a grid. Spatial Pixels class is analogous
- Download the file from this link
- Read the Spatial Grid class file
- Use slot function to do data exploration

```{r, echo = TRUE, warning = FALSE, message = FALSE}
auck_el1 <- readGDAL("70042108.tif")
class(auck_el1)
slot(auck_el1, "grid")
#slot(auck_el1, "grid.index")
#slot(auck_el1, "coords")
slot(auck_el1, "bbox")
object.size(auck_el1)
object.size(slot(auck_el1, "data"))
```

We can see the grid.index is empty, while the coords slot is as described earlier. It differs from the bounding box of the grid as a whole, contained in the bbox slot, by half a cell resolution value in each direction. We can use Spatial Pixels for this Spatial Grid
- Convert Spatial Grid to Spatial Pixel
- Perform similar kind of analysis we did for Spatial Grid using object.size
```{r, echo = TRUE, warning = FALSE, message = FALSE}
auck_el2 <- as(auck_el1, "SpatialPixelsDataFrame")
object.size(auck_el2)
object.size(slot(auck_el2, "grid.index"))
object.size(slot(auck_el2, "coords"))
sum(is.na(auck_el1$band1)) + nrow(slot(auck_el2, "coords"))
prod(slot(slot(auck_el2, "grid"), "cells.dim"))
```
We can create Spatial Pixels data frame directly from Spatial Points
- Read the data set
- Create Spatial Points data frame
- Convert the Spatial Points data frame to Spatial Pixels
```{r, echo = TRUE, warning = FALSE, message = FALSE}
data(meuse.grid)
mg_SP <- SpatialPoints(cbind(meuse.grid$x, meuse.grid$y))
summary(mg_SP)

mg_SPix0 <- SpatialPixels(mg_SP)
summary(mg_SPix0)
prod(slot(slot(mg_SPix0, "grid"), "cells.dim"))
```

### Traditional Plots

#### Plotting Points
- Read the data
- Checking the class type of data
- Creating Spatial Data frame for the data
- Plotting points
```{r, echo = TRUE, warning = FALSE, message = FALSE}
library(maps)
data(meuse)
head(meuse)
coordinates(meuse) <- c("x", "y")
head(meuse)
plot(meuse)
title("points")
```

#### Plotting Lines
- A SpatialLines object is made by joining up the points in sequence, and plot
draws the resulting zig-zags.
  + Extracting coordinates of the data
  + Creating Line Object which has coordinates as slot
  + Convert the object to list type
  + Creating Lines Object which has Line as slot using “1” as ID
  + Converting the Lines object to list type
  + Plotting the Lines

```{r, echo = TRUE, warning = FALSE, message = FALSE}
cc <- coordinates(meuse)
m.sl <- SpatialLines(list(Lines(list(Line(cc)), "1")))
plot(m.sl)
title("lines")
```

#### Plotting Polygons
- Read the data
- Check the class type of the data
- Creating Polygon Object using the data
- Convert the object to list type
- Creating Polygons Object from the list
- Converting the Polygons object to list type
- Plotting the Polygons

```{r, echo = TRUE, warning = FALSE, message = FALSE}
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)), "meuse.riv"))
meuse.sr <- SpatialPolygons(meuse.lst)
plot(meuse.sr, col = "grey")
title("polygons")
```

#### Plotting Grids
- Read the dataset
- Check the class type of data set
- Convert x and y to coordinates class
- Convert the data set to Grid class
- Plot the Grid
```{r, echo = TRUE, warning = FALSE, message = FALSE}
data(meuse.grid)
coordinates(meuse.grid) <- c("x", "y")
meuse.grid <- as(meuse.grid, "SpatialPixels")
image(meuse.grid, col = "grey")
title("grid")
```

#### Plotting All
- Rather than single plot the multiple type of plots gives exact picture of the data
  + Plot the Gird
  + Plot the Polygon
  + Plot the points
```{r, echo = TRUE, warning = FALSE, message = FALSE}
image(meuse.grid, col = "lightgrey")
plot(meuse.sr, col = "grey", add = TRUE)
plot(meuse, add = TRUE)
```

#### Labels and Axis
In general for maps the boundaries, coastlines, rivers reveal more information than axis. But we can customize maps axis and boundaries following way
- Create a layout
- Plot the graphs with axis
- Customize axis according to need
- Change margins for the plot
```{r, echo = TRUE, warning = FALSE, message = FALSE}
layout(matrix(c(1, 2), 1, 2))
plot(meuse.sr, axes = TRUE)
plot(meuse.sr, axes = FALSE)
axis(1, at = c(178000 + 0:2 * 2000), cex.axis = 0.7)
axis(2, at = c(326000 + 0:3 * 4000), cex.axis = 0.7)
box()
oldpar = par(no.readonly = TRUE)
layout(matrix(c(1, 2), 1, 2))
plot(meuse, axes = TRUE, cex = 0.6)
plot(meuse.sr, add = TRUE)
title("Sample locations")
par(mar = c(0, 0, 0, 0) + 0.1)
plot(meuse, axes = FALSE, cex = 0.6)
```
A typical map has directions suggesting north east and scale of the graph instead of x, y coordinates. We can add those details following way

#### Axes Labels and Reference Grids
When a grid needs to be added to a map, the function grid lines can be used to generate an object of class SpatialLines. Grid lines may be latitude/longitude grids, and these are non-straight lines. 
- Read the data
- Prune the map to the limits we need
- Convert the map to Spatial Lines
- Transform to required CRS system
- Create gridlines with new limits
- Plot the data

```{r, echo = TRUE, warning = FALSE, message = FALSE}
library(maptools)
library(maps)
wrld <- map("world", interior = FALSE, xlim = c(-179, 179), ylim = c(-89, 89), plot = FALSE)
wrld_p <- pruneMap(wrld, xlim = c(-179, 179))
llCRS <- CRS("+proj=longlat +ellps=WGS84")
wrld_sp <- map2SpatialLines(wrld_p, proj4string = llCRS)
prj_new <- CRS("+proj=moll")
wrld_proj <- spTransform(wrld_sp, prj_new)
wrld_grd <- gridlines(wrld_sp, easts = c(-179, seq(-150, 150, 50), 179.5), norths = seq(-75, 75, 15), ndiscr = 100)
wrld_grd_proj <- spTransform(wrld_grd, prj_new)
at_sp <- gridat(wrld_sp, easts = 0, norths = seq(-75, 75, 15), offset = 0.3)
 at_proj <- spTransform(at_sp, prj_new)
 plot(wrld_proj, col = "grey60")
plot(wrld_grd_proj, add = TRUE, lty = 3, col = "grey70")
text(coordinates(at_proj),pos = at_proj$pos, offset = at_proj$offset, labels = parse(text = as.character(at_proj$labels)), cex = 0.6)
```

#### Plot Size, Plotting Area, Map Scale, and Multiple Plots
- Control the total size of the figure
```{r, echo = TRUE, warning = FALSE, message = FALSE}
par("pin")
par(pin = c(4, 4))
```
- Enlarge the plotting window (we may have to close the current plotting device and re-open it specifying size)
```{r, echo = TRUE, warning = FALSE, message = FALSE}
dev.off()
#X11(width = 10, height = 10)
```
- Writing graphic output to files
```{r, echo = TRUE, warning = FALSE, message = FALSE}
postscript("file.ps", width = 10, height = 10)
```
- Control the data area plotted 
```{r, echo = TRUE, warning = FALSE, message = FALSE}
par(xaxs="i")
par(yaxs="i")
```
- In the following example
```{r, echo = TRUE, warning = FALSE, message = FALSE}
pin <- par("pin")
dxy <- apply(bbox(meuse), 1, diff)
ratio <- dxy[1]/dxy[2]
par(pin = c(ratio * pin[2], pin[2]), xaxs = "i", yaxs = "i")
plot(meuse, pch = 1)
box()
```
- Create more than one map in a single figure
```{r, echo = TRUE, warning = FALSE, message = FALSE}
par(mfrow = c(2, 3))
layout(matrix(1:6, 2, 3, byrow = TRUE))
```
Map scale is the ratio between the length of one unit on the map and one unit in the real world. It can only be controlled ahead of time when both the size of the plotting region and the plotting area are defined or otherwise exactly known.

#### Plotting Attributes and Map Legends
In order to show feature characteristics or attributes of the objects, we need to use type, size, or colour of the symbols, lines, or polygons. Map legend is needed for a specific colour, size, or symbol type. 
```{r, echo = TRUE, warning = FALSE, message = FALSE}
grays = gray.colors(4, 0.55, 0.95)
#image(zn.idw, col = grays, breaks = log(c(100, 200, 400, 800, 1800)))
plot(meuse.sr)
plot(meuse, pch = 1, cex = sqrt(meuse$zinc)/20, add = TRUE)
legVals <- c(100, 200, 500, 1000, 2000)
legend("left", legend = legVals, pch = 1, pt.cex = sqrt(legVals)/20, bty = "n", title = "measured")
legend("topleft", legend = c("100-200", "200-400", "400-800", "800-1800"), fill = grays, bty = "n", title = "interpolated")
```

### Trellis/Lattice Plots
- Trellis plots are a bit harder to deal with initially because plot annotation, the addition of information like legend, lines, text, etc., is handled differently and needs to be thought out first. The advantage they offer is that many maps can be composed into single (sets of) graphs, easily and efficiently.
- Plotting on normal scale and log scale
```{r, echo = TRUE, warning = FALSE, message = FALSE}
# levelplot(z ~ x + y | name, spmap.to.lev(zn[c("direct", "log")]), asp = "iso")
# spplot(zn[c("direct", "log")])
```

#### Plotting Points, Lines, Polygons, and Grids
Function spplot plots spatial objects using colour (or grey tone) to denote
attribute values. The first argument therefore has to be a spatial object with
Attributes. We can use spplot for Multiple plots too.
- The first argument to spplot is a Spatial DataFrame object with points, lines, polygons, or a grid. 
- The second argument tells which attributes (column names or numbers) should be used; if omitted, all attributes are plotted.
- Further attributes control the plotting: colours, symbols, legend classes, size, axes, and geographical reference items to be added.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
data(meuse.grid)
coordinates(meuse.grid) <- c("x", "y")
meuse.grid <- as(meuse.grid, "SpatialPixelsDataFrame")
im <- as.image.SpatialGridDataFrame(meuse.grid["dist"])
cl <- ContourLines2SLDF(contourLines(im))
spplot(cl)
```
#### Adding Reference and Layout Elements to Plots
- Method spplot takes a single argument, sp.layout, to annotate plots with lines, points, grids, polygons, text, or combinations of these. This argument contains either a single layout item or a list of layout items. 
- A single layout item is a list object. 
- Its first component is the name of the layout function to be called, followed by the object to be plotted and then optional arguments to adjust colour, symbol, size, etc. 
```{r, echo = TRUE, warning = FALSE, message = FALSE}
river <- list("sp.polygons", meuse.sr)
north <- list("SpatialPolygonsRescale", layout.north.arrow(), offset = c(178750, 332500), scale = 400)
scale <- list("SpatialPolygonsRescale", layout.scale.bar(), offset = c(180200, 329800), scale = 1000, fill = c("transparent", "black")) 
txt1 <- list("sp.text", c(180200, 329950), "0") 
txt2 <- list("sp.text", c(181200, 329950), "1 km")
pts <- list("sp.points", meuse, pch = 3, col = "black")
meuse.layout <- list(river, north, scale, txt1, txt2, pts)
#spplot(zn["log"], sp.layout = meuse.layout)
```

### Interacting with Plots
The interaction R allows with plots in the traditional and lattice plot systems
is rather limited, compared with stand-alone software written for interacting
with data, or GIS. The main functionality is centred around which information
is present at the location where a mouse is clicked.
Interacting with Base Graphics
- Base graphics has two functions to interact with interactive (i.e. screen) graphic devices: 
  + ‘locator’ returns the locations of points clicked, in coordinates of the x- and y-axis 
  + ‘identify’ plots and returns the labels of the items nearest to the location clicked, within a specified maximum distance 
- Both functions wait for user input
  + Left mouse clicks are registered
  + Right mouse click ends the input
- To identify particular polygons, we can use locator and overlay the points with the polygon layer

#### Interacting with spplot and Lattice Plots
- In R, Trellis (lattice) plots have the same interaction functionality as base plots. However, the process is a bit more elaborate because multiple panels may be present.
- To select points with spplot, use
```{r, echo = TRUE, warning = FALSE, message = FALSE}
ids <- spplot(meuse, "zinc", identify = TRUE)
```
- This will show the points selected and return the selected points’ row numbers.
- Digitising can be done by the function grid.locator from package grid, which underlies the functionality in lattice. A single point is selected by

#### Colour Palettes and Class Intervals
- Rprovides a number of colour palettes, and the functions providing them are selfdescriptive: rainbow, grey.colors, heat.colors, terrain.colors, topo.colors, and cm.colors (cm for cyan-magenta) – cm.colors are the default palette in spplot and diverge from white.
- For quantitative data, shades in a single colour are usually preferred. These can be created by colorRampPalette, which creates a color interpolating function taking the required number of shades as
```{r, echo = TRUE, warning = FALSE, message = FALSE}
rw.colors <- colorRampPalette(c("red", "white"))
image(meuse.grid["dist"], col = rw.colors(10))
```
- Package RColorBrewer provides the palettes described for continuous, diverging, and categorical variables. An interface for exploring how these palettes look on maps is found in the colorbrewer (See http://www.colorbrewer.org/)
- It also has information on suitability of each of the palettes for colourblind people, black-and-white photo-copying, projecting by LCD projectors, use on LCD or CRT screens, and for colour printing. Another, non-interactive, overview is obtained by
```{r, echo = TRUE, warning = FALSE, message = FALSE}
example(brewer.pal)
```
- Package sp provides the ramp bpy.colors (blue-pink-yellow), which has the advantage that it has many colors and that it prints well both on color and black-and-white printers.

#### Class Intervals
- Class intervals can be chosen in many ways, and some have been collected for convenience in the classInt package. 
- The first problem is to assign class boundaries to values in a single dimension, for which many classification techniques may be used, including pretty, quantile, and natural breaks among others, or even simple fixed values.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
pal <- grey.colors(4, 0.95, 0.55, 2.2)
q5 <- classIntervals(meuse$zinc, n = 5, style = "quantile")
diff(q5$brks)
plot(q5, pal = pal)
```
- The empirical cumulative distribution function, used in the plot method for the classIntervals object returned, suggests that using quantiles is not necessarily a good idea. While of course the number of sites in each class is equal by definition, the observed values are far from uniformly distributed. 
- Examining the widths of the classes using diff on the class breaks shows that many sites with moderate zinc values will be assigned to the darkest colour class.
- Five-class Fisher-Jenks classification. There are two implementations of this style, one named ‘fisher’, the other ‘jenks’. This ‘natural breaks’ set of class intervals is based on minimising the within-class variance, like many of the other styles available.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
fj5 <- classIntervals(meuse$zinc, n = 5, style = "fisher")
fj5
diff(fj5$brks)
plot(fj5, pal = pal)
```
- Once we are satisfied with the chosen class intervals and palette, we can go on to plot the data, using the findColours function to build a vector of colours and attributes, which can be used in constructing a legend
```{r, echo = TRUE, warning = FALSE, message = FALSE}
q5Colours <- findColours(q5, pal)
plot(meuse, col = q5Colours, pch = 19)
legend("topleft", fill = attr(q5Colours, "palette"), legend = names(attr(q5Colours, "table")), bty = "n")
```
- While the classIntervals function can be used with raster data, it may be prudent to search for class intervals using a sample of the input data, including the extremities to save time; this heuristic is used by many GIS. The default class interval style used by image is to divide the range into a number of classes of equal width (equivalent to the equal or pretty styles in classIntervals).
- With very skewed data, for example 2D density plots, this may give the impression of the data having disappeared, because almost all the cells will be in one extreme class, and only a few in other classes. Changing the class intervals will ‘magically’ reveal the data.
- To specify class intervals with spplot, for points data we can pass the cuts argument, and for lines, polygons, or grids we can pass the at argument. To also control the key tic marks and labels, we need to specify colorkey as well.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
cuts = (0:10)/10
spplot(meuse.grid, "dist", colorkey = list(labels = list(at = cuts)), at = cuts)
```

### Coordinate Reference Systems
- Spatial data vary a great deal both in the ways in which their position attributes are recorded and in the adequacy of documentation of how position has been determined.
- Knowledge about the coordinate reference system is needed to establish the positional coordinates’ units of measurement, obviously needed for calculating distances between observations and for describing the network topology of their relative positions
- Projected CRS are expressed by a specific geometric model projecting to the plane and measures of length, as well as the underlying ellipse, prime meridian, and datum

#### EPSG: European Petroleum Survey Group
- It is available in library(rgdal)
- EPSG can be read as dataframe 
- make_EPSG( ) has the full list of EPSG
- Use grep to find the exact list we are looking for
```{r, echo = TRUE, warning = FALSE, message = FALSE}
EPSG <- make_EPSG()
EPSG[grep("^# ED50$", EPSG$note), ]
```
- The EPSG list provides a good deal of help, but assumes that wrong help is worse than no help, and does not give transformation parameters where there is any ambiguity

#### PROJ.4 CRS Specification
- The PROJ.4 library uses a ‘tag = value’ representation of coordinate reference systems, with the tag and value pairs enclosed in a single character string. 
- There are a number of different tags, always beginning with +, and separated from the value with =, using white space to divide the tag/value pairs from each other.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
CRS("+init=epsg:4230")
ED50 <- CRS("+init=epsg:4230 +towgs84=-87,-96,-120,0,0,0,0")
IJ.east <- as(char2dms("4d31'00\"E"), "numeric")
IJ.north <- as(char2dms("52d28'00\"N"), "numeric")
IJ.ED50 <- SpatialPoints(cbind(x = IJ.east, y = IJ.north), ED50)
res <- spTransform(IJ.ED50, CRS("+proj=longlat +datum=WGS84"))
x <- as(dd2dms(coordinates(res)[1]), "character")
y <- as(dd2dms(coordinates(res)[2], TRUE), "character")
cat(x, y, "\n")
spDistsN1(coordinates(IJ.ED50), coordinates(res), longlat = TRUE) * 1000
gzAzimuth(coordinates(IJ.ED50), coordinates(res))
EPSG[grep("Atlas", EPSG$note), 1:2]
CRS("+init=epsg:2163")
```
- For example, the US National Atlas has chosen a particular CRS for its view of the continental US, with a particular set of tags and values to suit. The projection chosen has the value laea, which, like many other values used to represent CRS in PROJ.4 and elsewhere, is rather cryptic.
- The projInfo function can return several kinds of information in tabular form, and those tables can be examined to shed a little more light on the tag values.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
proj <- projInfo("proj")
proj[proj$name == "laea", ]
ellps <- projInfo("ellps")
ellps[grep("a=6370997", ellps$major), ]
```
While importing and exporting data – if their CRS specifications are known, transferring positional data correctly becomes much easier

#### Degrees, Minutes, and Seconds
- In common use, the sign of the coordinate values may be removed and the value given a suffix of E or N for positive values of longitude or latitude and W or S for negative values.
- In addition, values are often recorded traditionally not as decimal degrees, but as degrees, minutes, and decimal seconds, or some truncation of this.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
IJ.dms.E <- "4d31'00\"E"
IJ.dms.N <- "52d28'00\"N"
```
- We convert these character strings to class ‘DMS’ objects, using function char2dms:
```{r, echo = TRUE, warning = FALSE, message = FALSE}
IJ_east <- char2dms(IJ.dms.E)
IJ_north <- char2dms(IJ.dms.N)
IJ_east
IJ_north
getSlots("DMS")
```
- The DMS class has slots to store representations of geographical coordinates, however, they might arise, but the char2dms() function expects the character input format to be as placed, permitting the degree, minute, and second symbols to be given as arguments.
- We get decimal degrees by coercing from class ‘DMS’ to class ‘numeric’ with the as() 
```{r, echo = TRUE, warning = FALSE, message = FALSE}
c(as(IJ_east, "numeric"), as(IJ_north, "numeric"))
```
#### Vector File Formats
- Spatial vector data are points, lines, polygons, and fit the equivalent sp classes.
- Vector formats can also be converted outside R to formats for which import is feasible.
- GIS vector data can be either topological or simple. Legacy GIS were topological, desktop GIS were simple. 
- The sp vector classes are simple
- GRASS 6 open source GIS has such a topological representation of vector features.
- RArcInfo package tries to keep some traces of topology in importing legacy
- ESRI™ ArcInfo™ maps uses topology
- The import of ArcGIS™ and conversion of imported features into sp classes is handled by the pal2SpatialPolygons function in maptools.

Shapefile:
A format that is commonly used for exchanging vector data is the shapefile. This file format has been specified by ESRI™, the publisher of ArcView™ and ArcGIS™, which introduced it initially to support desktop mapping using ArcView™.13 This format uses at least three files to represent the data, a file of geometries with an *.shp extension, an index file to the geometries *.shx, and a legacy *.dbf DBF III file for storing attribute data. 
If a *.prj file is present, it will contain an ESRI™ well-known text CRS specification. The shapefile format is not fully compatible with the OpenGIS® Simple Features Specification

#### Using OGR Drivers in rgdal
- Using the OGR vector functions of the Geospatial Data Abstraction Library, interfaced in rgdal,14 lets us read spatial vector data for which drivers are available. 
- OGR also supports the handling of coordinate reference systems directly, so that if the imported data have a specification, it will be read.
- The availability of OGR drivers differs from platform to platform, and can be listed using the ogrDrivers function. The function also lists whether the driver supports the creation of output files.
- It is frequently convenient to convert from one external file format to another using utility programs such as ogr2ogr in binary FWTools releases, which typically include a wide range of drivers.
- The readOGR function takes at least two arguments – they are the data source name (dsn) and the layer (layer), and may take different forms for different drivers. For ESRI™ shapefiles, dsn is usually the name of the directory containing the three (or more) files to be imported (given as "." if the working directory), and layer is the name of the shapefile without the ".shp" extension.
```{r, echo = TRUE, warning = FALSE, message = FALSE}
download.file("http://web1.sph.emory.edu/users/lwaller/book/ch9/scot.shp", "scot.shp", mode="wb")
#download.file("http://www.sph.emory.edu/~lwaller/book/ch9/scot.shp", "scot.shp", mode="wb")
download.file("http://web1.sph.emory.edu/users/lwaller/book/ch9/scot.dbf", "scot.dbf", mode="wb")
download.file("http://web1.sph.emory.edu/users/lwaller/book/ch9/scot.shx", "scot.shx", mode="wb")
scot_LL <- readOGR(".", "scot")
proj4string(scot_LL) <- CRS("+proj=longlat +ellps=WGS84")
scot_dat <- read.table("scotland.dat", skip = 1)
names(scot_dat) <- c("District", "Observed", "Expected", "PcAFF", "Latitude", "Longitude")
scot_dat$District
scot_dat1 <- scot_dat[match(scot_LL$ID, scot_dat$District), ]
row.names(scot_dat1) <- sapply(slot(scot_LL, "polygons"), function(x) slot(x, "ID"))
scot_LLa <- spCbind(scot_LL, scot_dat1)
all.equal(scot_LLa$ID, scot_LLa$District)
O <- scot_LLa$Observed
E <- scot_LLa$Expected
scot_LLa$SMR <- probmap(O, E)$relRisk/100
scot_LLa$smth <- empbaysmooth(O, E)$smthrr
scot_BNG <- spTransform(scot_LLa, CRS("+init=epsg:27700"))
```
- We export these data in two forms, first as Keyhole Markup Language (KML) overlays for Google Earth™. The underlying coordinate reference system for Google Earth™ is geographical, in the WGS84 datum, so we can export the district boundaries as we imported them, using the writeOGR function, choosing only a single variable. 
This function, like readOGR, uses drivers to handle different data formats, with driver="KML" in this case. Next we take the district centroids and export them as a SpatialPointsDataFrame, with the district name, the observed and expected values, and the two rates:
```{r, echo = TRUE, warning = FALSE, message = FALSE}
#writeOGR(scot_LLa["ID"], dsn = "scot_district.kml",layer = "borders", driver = "KML")
llCRS <- CRS("+proj=longlat +ellps=WGS84")
scot_SP_LL <- SpatialPointsDataFrame(coordinates(scot_LLa), proj4string = llCRS, data = as(scot_LLa, "data.frame")[c("NAME", "Observed", "Expected", "SMR", "smth")])
writeOGR(scot_SP_LL, dsn = "scot_rates.kml", layer = "rates", driver = "KML")
drv <- "ESRI Shapefile"
#writeOGR(scot_BNG, dsn = ".", layer = "scot_BNG", driver = drv)
list.files(pattern = "^scot_BNG")
```
#### Raster File Formats
- There are very many raster and image formats 
	+ some allow only one band of data 
	+ others assume that data bands are Red-Green-Blue (RGB) 
	+ while yet others are flexible and self-documenting. 
- The simplest formats are just rectangular blocks of uncompressed data, like a matrix, but sometimes with row indexing reversed. 
- Others are compressed, with multiple bands, and may be interleaved so that subscenes can be retrieved without unpacking the whole image. 
- There are now a number of R packages that support image import and export, such as the rimage and biOps packages and the EBImage package in the Bioconductor project. 
- The requirements for spatial raster data handling include respecting the coordinate reference system of the image, so that specific solutions are needed.

#### Using GDAL Drivers in rgdal
- Many drivers are available in rgdal in the readGDAL function, which – like readOGR – finds a usable driver if available and proceeds from there. Using
arguments to readGDAL, subregions or bands may be selected, and the data may be decimated, which helps handle large rasters. 
```{r, echo = TRUE, warning = FALSE, message = FALSE}
auck_el1 <- readGDAL("70042108.tif")
summary(auck_el1)
is.na(auck_el1$band1) <- auck_el1$band1 <= 0 | auck_el1$band1 > 10000
```
- The writeGDAL function can be used directly for drivers that support file creation. For other file formats, which can be made as copies of a prototype, we need to create an intermediate GDAL data set using create2GDAL, and then use functions operating on the GDAL data set handle to complete
```{r, echo = TRUE, warning = FALSE, message = FALSE}
log_zinc <- krige(log(zinc) ~ 1, meuse, meuse.grid)["var1.pred"]
proj4string(log_zinc) <- CRS(proj4string(meuse.grid))
summary(log_zinc)
writeGDAL(log_zinc, fname = "log_zinc.tif", driver = "GTiff", type = "Float32", options = "INTERLEAVE=PIXEL")
GDALinfo("log_zinc.tif")
```
#### Writing a Google Earth™ Image Overlay
- Attempt to export anything that can be plotted on a PNG graphics device. 
- First we make a polygon to bound the study area and project it to geographical coordinates:
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
grd <- as(meuse.grid, "SpatialPolygons")
proj4string(grd) <- CRS(proj4string(meuse))
gpclibPermit()
grd.union <- unionSpatialPolygons(grd, rep("x", length(slot(grd, "polygons"))))
ll <- CRS("+proj=longlat +datum=WGS84")
grd.union.ll <- spTransform(grd.union, ll)
```
- Next we construct a suitable grid in geographical coordinates, as our target object for export, using the GE_SpatialGrid wrapper function. This grid is also
the container for the output PNG graphics file
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
llGRD <- GE_SpatialGrid(grd.union.ll)
llGRD_in <- overlay(llGRD$SG, grd.union.ll)
llSGDF <- SpatialGridDataFrame(grid = slot(llGRD$SG, "grid"), proj4string = CRS(proj4string(llGRD$SG)), data = data.frame(in0 = llGRD_in))
llSPix <- as(llSGDF, "SpatialPixelsDataFrame")
```
- Since we have used GE_SpatialGrid to set up the size of an R png graphics device, we can now use it as usual, here with image. In practice, any base graphics methods and functions can be used to create an image overlay. Finally, after closing the graphics device, we use kmlOverlay to write a *.kml file giving the location of the overlay and which will load the image at that position when opened in Google Earth™
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
png(file = "zinc_IDW.png", width = llGRD$width,height = llGRD$height, bg = "transparent")
par(mar = c(0, 0, 0, 0), xaxs = "i", yaxs = "i")
image(llSPix, "pred", col = bpy.colors(20))
dev.off()
kmlOverlay(llGRD, "zinc_IDW.kml", "zinc_IDW.png")
```

#### GRASS
- It provided a compiled interface to raster and sites data, but not vector data, and included a frozen copy of the core GRASS GIS C library, modified to suit the fact that its functions were being used in an interactive, longer-running program like R
GRASS also uses the concepts of a location, with a fixed and uniform coordinate reference system, and of mapsets within the location. The location is typically chosen at the start of a work session, and with the location, the user will have read access to possibly several mapsets, and write access to some, probably fewer, to avoid overwriting the work of other users of the location.
R is started from within a GRASS session from the command line, and the spgrass6 loaded with its dependencies:
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
system("g.version", intern = TRUE)
gmeta6()
```
- The readRAST6 command here reads elevation values into a SpatialGridDataFrame object, treating the values returned as floating point and the geology categorical layer into factor:
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
spear <- readRAST6(c("elevation.dem", "geology"), cat = c(FALSE, TRUE))
summary(spear)
table(spear$geology)
system("r.stats --q -cl geology", intern = TRUE)
```
- writeRAST6 function allows a single named column of a SpatialGridDataFrame object to be exported to GRASS.
- The spgrass6 package also provides functions to move vector features and associated attribute data to R and back again; unlike raster data, there is no standard mechanism for handling missing values. The readVECT6 function is used for importing vector data into R, and writeVECT6 for exporting to GRASS. The first data set to be imported from GRASS contains the point locations of sites where insects have been monitored, the second is a set of stream channel centre-lines:
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
bugsDF <- readVECT6("bugsites")
vInfo("streams")
streams <- readVECT6("streams", type = "line,boundary", remove.duplicates = FALSE)
```
#### Cholera Data
```{r, echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE}
buildings <- readVECT6("vsnow4")
sohoSG <- readRAST6(c("snowcost_broad", "snowcost_not_broad"))
deaths <- readVECT6("deaths3")
o <- overlay(sohoSG, deaths)
deaths <- spCbind(deaths, as(o, "data.frame"))
deaths$b_nearer <- deaths$snowcost_broad < deaths$snowcost_not_broad
by(deaths$Num_Cases, deaths$b_nearer, sum)
```






